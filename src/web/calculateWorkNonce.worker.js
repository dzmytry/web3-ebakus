import clz from 'clz-buffer'
import cryptonight from 'url-loader?name=[name].[ext]!../common/cryptonight.js'

// import { keccak256 } from 'eth-lib/lib/hash'
import { hex2uint8 } from '../common/utils'
import { keccak256 } from 'js-sha3'

importScripts(cryptonight) // imports the cryptonight.js "glue" script generated by emscripten

// webassembly cryptonight is called here.
const cn = Module.cwrap('cryptonight', '', [
  /*'number', 'number', 'number', 'number', 'number'*/
])

const getCryptoNightBigEndian = (input, output) => {
  cn(
    output.byteOffset,
    input.byteOffset,
    input.byteLength,
    /* lite */ 0,
    /* variant */ 2
  )

  // reverse from little-endian to big-endian
  output.reverse()
}

const throttled = (delay, fn) => {
  let lastCall = 0
  return function(...args) {
    const now = new Date().getTime()
    if (now - lastCall < delay) {
      return
    }
    lastCall = now
    return fn(...args)
  }
}

onmessage = function(e) {
  const { hash, targetDifficulty } = e.data
  let currentWorkNonce = 0

  const mainThreadUpdate = throttled(500, () => {
    // emit the final workNonce calculated for transaction
    postMessage({
      cmd: 'current',
      workNonce: currentWorkNonce,
    })
  })

  // calculate a cryptonight hash
  function calculateWorkNonce() {
    let bits = Math.log2(targetDifficulty)
    bits = Math.ceil(bits)
    const target = bits

    // const heap1 = Module.HEAPU8.buffer
    // console.log('TCL: calculateWorkNonce -> heap1', heap1)
    // const input1 = new Uint8Array(heap, Module._malloc(64), 64)
    // console.log('TCL: calculateWorkNonce -> input1', input1)

    // const rlpIntArray = hex2uint8(heap, hash, Module._malloc(hash.length / 2))
    // const rlpHash = new Uint8Array(heap, Module._malloc(32), 32)
    // getCryptoNightBigEndian(rlpIntArray, rlpHash)

    // input.set(rlpHash, 0)

    var heap = new ArrayBuffer(512)
    console.log('TCL: calculateWorkNonce -> heap', heap)
    var input = new Uint8Array(heap, 64, 64)
    console.log('TCL: calculateWorkNonce -> input', input)
    // const rlpHash = keccak256(hash)
    const rlpHashBuffer = keccak256.arrayBuffer(hash)
    const rlpHash = new Uint8Array(rlpHashBuffer)
    // const rlpIntArray = hex2uint8(heap, hash, Module._malloc(hash.length / 2))
    console.log('TCL: calculateWorkNonce -> rlpHash', rlpHash)

    // 0x5460288f1ef9833c82561082d2a02383c3cb28e4a34c8f9d93560e0934b56767
    input.set(rlpHash)

    // console.log('TCL: calculateWorkNonce -> input2', input)

    const inputDataView = new DataView(heap, input.byteOffset, input.byteLength)

    // const outputMalloc = Module._malloc(32)
    let bestBit = 0
    do {
      // set in big-endian
      inputDataView.setUint32(60, currentWorkNonce)

      // console.log(
      //   'TCL: calculateWorkNonce -> inputDataView',
      //   inputDataView,
      //   input
      // )

      // const outputHash = new Uint8Array(heap, outputMalloc, 32)
      // getCryptoNightBigEndian(input, outputHash)
      const outputHash = new Uint8Array(keccak256.arrayBuffer(input))

      const firstBit = clz(outputHash)
      console.log('TCL: calculateWorkNonce -> outputHash', outputHash, firstBit)

      if (firstBit > bestBit) {
        bestBit = firstBit

        if (bestBit >= target) {
          break
        }
      }

      currentWorkNonce++

      mainThreadUpdate()
    } while (bestBit <= target)
  }

  calculateWorkNonce()

  // emit the final workNonce calculated for transaction
  postMessage({
    cmd: 'finished',
    workNonce: currentWorkNonce,
  })
}

Module.onRuntimeInitialized = () => {
  // emit to main thread that worker has finished loading
  postMessage({
    cmd: 'ready',
  })
}
